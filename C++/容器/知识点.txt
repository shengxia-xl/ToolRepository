STL中容器的对比
https://blog.csdn.net/u014465639/article/details/70241850
STL中容器线程安全
https://www.cnblogs.com/ztteng/archive/2013/11/07/3411738.html

----------------------------------------------------------------------------------------------------
关于stl中容器的线程安全

多个读取者是安全的
对不同容器的多个写入者是安全的。

部分方法是安全的 
其大意也是，为了效率，没有给所有操作加锁。

----------------------------------------------------------------------------------------------------

容器的种类

  1、顺序容器：是一种各元素之间有顺序关系的线性表，是一种线性结构的可序群集。顺序性容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。顺序容器包括：vector(向量)、list（列表）、deque（队列）。
  2、关联容器：关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。但是关联式容器提供了另一种根据元素特点排序的功能，这样迭代器就能根据元素的特点“顺序地”获取元素。元素是有序的集合，默认在插入的时候按升序排列。关联容器包括：map（集合）、set（映射）、multimap（多重集合）、multiset（多重映射）。
  3、容器适配器：本质上，适配器是使一种不同的行为类似于另一事物的行为的一种机制。容器适配器让一种已存在的容器类型采用另一种不同的抽象类型的工作方式实现。适配器是容器的接口，它本身不能直接保存元素，它保存元素的机制是调用另一种顺序容器去实现，即可以把适配器看作“它保存一个容器，这个容器再保存所有元素”。STL 中包含三种适配器：栈stack 、队列queue 和优先级队列priority_queue 。

  容器类自动申请和释放内存，因此无需new和delete操作。


STL中的容器分为

1.vector
（连续的空间存储,可以使用[]操作符）快速的访问随机的元素，快速的在末尾插入元素，但是在序列中间岁间的插入，删除元素要慢（涉及元素复制移动），而且如果一开始分配的空间不够的话，有一个重新分配更大空间，此时需要拷贝的性能开销。可以快速地在最后添加删除元素,并可以快速地访问任意元素

2.deque
在开始和最后添加删除元素都一样快,并提供了随机访问方法,像vector一样使用[]访问任意元素,但是随机访问速度比不上vector快,因为它要内部处理堆跳转deque也有保留空间.另外,由于deque不要求连续空间,所以可以保存的元素比vector更大,这点也要注意一下.还有就是在前面和后面添加元素时都不需要移动其它块的元素。对deque的排序操作，可将deque先复制到vector，排序后在复制回deque。
1)两端都能快速插入元素和删除元素（vector只在尾端快速进行此类操作）。
2）存取元素时，deque的内部结构会多一个间接过程，所以元素的存取和迭代器的动作会稍稍慢一些。
3）迭代器需要在不同区块间跳转，所以必须是特殊的智能型指针，非一般指针。
4）在对内存区块有所限制的系统中（例如PC系统），deque可以内含更多元素，因为它使用不止一块内存。因此deque的max_size()可能更大。
5）deque不支持对容量和内存重分配时机的控制。特别要注意的是，除了头尾两端，在任何地方插入或删除元素，都将导致指向deque元素的任何指针、引用、迭代器失效。不过，deque的内存重分配优于vector，因为其内部结构显示，deque不必在内存重分配时复制所有元素。
6）deque的内存区块不再被使用时，会被释放。deque的内存大小是可缩减的。

3.list
（元素间使用链表相连）访问随机元素不如vector快，随机的插入元素比vector快，对每个元素分配空间，所以不存在空间不够，重新分配的情况。list可以快速地在所有地方添加删除元素,但是只能快速地访问最开始与最后的元素

4.set
内部元素唯一，用一棵平衡树结构来存储，因此遍历的时候就排序了，查找比较快。

5.map
一对一的映射的结合，key不能重复。

hashset hashmap 是由hash实现的。

1.强调快速随机访问。则vector要比list好得多 。
2.已知要存储元素的个数。vector 好于list。  
3.强调增删且不要在两端插入修改元素。则list显然要比vector好。  
4.除非我们需要在容器首部插入和删除元素，deque好于vector。因为vector仅仅在尾部增删快速。
6.如果只需要在读取输入时在容器的中间位置插入元素，然后需要随机访问元素，则可考虑输入时将元素读入到一个List容器，然后排序，然后将排序后的list容器复制到一个vector容器中。
5.如果只在容易的首部和尾部插入数据元素，则选择deque.


----------------------------------------------------------------------------------------------------

C++ STL常用容器删除操作注意事項
https://blog.csdn.net/u010090316/article/details/70244859

vector 
vector 容器是用数组实现的, 它在内存是连续分布的.对它进行 insert 或 erase 操作涉及到对插入点或删除点后的元素进行移位, 所以插入点或删除点后的iterator 会失效.
//删除 vector1中值等于 num 的元素
for(; it != vector1.end(); ) {
    if(num == *it)
        it = vector1.erase(it);
    else
        ++it;
}

list
STL 的list容器是采用双向链表实现的,使用不连续的内存空间存储元素.inser时不会导致任何迭代器失效,erase 时删除点的迭代器失效, 但是不影响其他迭代器.它的erase函数类似vector,该函数返回值是当前迭代器指针的下一个迭代器.但是由于底层实现不同,list的删除操作可以采用更加灵活地方式.
//删除 list1中值等于 num 的元素
for(; it != list1.end(); ) {
    if(num == *it)
        it = list1.erase(it);
        //list1.erase(it++); //also OK
    else
        ++it;
}

map
STL的 map 容器底层采用红黑树实现, 也就是说是一种平衡二叉树, 它的插入和删除效果和 list 类似.inser时不会导致任何迭代器失效, erase 时只有删除点的迭代器失效, 其他迭代器不受影响.
 // 删除 map1中所有 key 为奇数的元素
for(auto it = map1.begin(); it != map1.end(); ) {        
    if(it->first % 2 == 1)
        //it = map1.erase(it);
        map1.erase(it++);
    else
        ++it;
}

其他容器如 dequeue的操作方法借鉴vector, set 可以借鉴 map