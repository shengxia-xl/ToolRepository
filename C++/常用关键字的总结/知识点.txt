C/C++文字常量与常变量
https://blog.csdn.net/k346k346/article/details/46448255
----------------------------------------------------------------------------------------------------
const  代码区，不可寻址，不可更改
使用const定义的对象为常对象 以下两种定义形式在本质上是一样的
const Point point1(10,10);//常量对象
Point const point2(10,10);//常量对象

修饰指针
如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。
推荐使用int const* p，而不是使用const int* p(两者意义完全一样)

修饰函数参数(用const修饰函数参数，传递过来的参数在函数内不可以改变)
void func (const int& n)

用const修饰的类对象，该对象内的任何成员变量都不能被修改。
因此不能调用该对象的任何非const成员函数，因为对非const成员函数的调用会有修改成员变量的企图。

class A
{
 public:
    void funcA() {}
    void funcB() const {}
};

const A a;
a.funcB();    // 可以
a.funcA();    // 错误
const A* b = new A();
b->funcB();    // 可以
b->funcA();    // 错误

const修饰的声明数据成员成为常数据成员
说明： 
 1 任何函数都不能对常数据成员赋值。
 2 构造函数对常数据成员进行初始化时也只能通过初始化列表进行。
 3 常数据成员在定义时必须赋值或称为必须初始化。
 4 如果类有多个默认构造函数必须都初始化常数据成员。

const修饰的声明成员函数成为常成员函数
说明： 
 1 const是函数类型的一部分，在实现部分也要带该关键字。
 2 const关键字可以用于对重载函数的区分。
 3 常成员函数不能更新任何数据成员，也不能调用该类中没有用const修饰的成员函数，只能调用常成员函数和常数据成员。

const_cast
const_cast运算符用来修改类型的const或volatile属性。
值得注意的是：它只对指针、引用和其它的具有指向性质的类型.
一、常量指针被转化成非常量的指针，并且仍然指向原来的对象；
二、常量引用被转换成非常量的引用，并且仍然指向原来的对象。

在C++中，mutable 是为了突破 const 的限制而设置的。可以用来修饰一个类的成员变量。被 mutable 修饰的变量，将永远处于可变的状态，即使是 const 函数中也可以改变这个变量的值。

volatile修饰的数据,编译器不可对其进行执行期寄存于寄存器的优化.
这种特性,是为了多线程同步的需要

拓展：
const与define的区别

define是宏定义
1,不进行数据类型检验,注意“边缘效应” #define N (2+3)/ #define N 2+3
2,程序在预处理阶段将用define定义的内容进行替换因此程序运行时，常量表中并没有用define定义的常量，系统不为它分配内存
3,#define定义的常量在内存中有若干个拷贝。

const定义的常量
1,在编译时进行严格的类型检验
2,编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
3,const常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝

const定义的常量叫做常变量原因有二：
1，const定义常量像变量一样检查类型。
2，const可以在任何地方定义常量，编译器对它的处理过程与变量相似，只是分配内存的地方不同
----------------------------------------------------------------------------------------------------

把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。
把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。
默认初始化为0（static变量）

类中的static
类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数

不能将静态成员函数定义为虚函数。虚函数需要对象 运行时多态。

由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”

struct中的static变量,sizeof的时候不计算static变量的大小。static不属于对象

----------------------------------------------------------------------------------------
在C++中，mutable 是为了突破 const 的限制而设置的。可以用来修饰一个类的成员变量。被 mutable 修饰的变量，将永远处于可变的状态，即使是 const 函数中也可以改变这个变量的值。

volatile修饰的数据,编译器不可对其进行执行期寄存于寄存器的优化.
这种特性,是为了多线程同步的需要
----------------------------------------------------------------------------------------------------

在C++中，如果一个类有只有一个参数的构造函数，C++允许一种特殊的声明类变量的方式。在这种情况下，可以直接将一个对应于构造函数参数类型的数据直接赋值给类变量，编译器在编译时会自动进行类型转换，将对应于构造函数参数类型的数据转换为类的对象。如果在构造函数前加上explicit修饰词，则会禁止这种自动转换，在这种情况下，即使将对应于构造函数参数类型的数据直接赋值给类变量，编译器也会报错。

explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。

class People 
{ 
public: 
	int age; 
	People (int a)  {    age=a;  } 
};

void foo ( void ) 
{   
	People p1(10);  //方式一  
	People* p_p2=new People(10); //方式二  
	People p3=10; //方式三 
}
----------------------------------------------------------------------------------------------------

extern(extern一般是使用在多文件之间需要共享某些代码时)
如果想声明一个变量而非定义它，就在变量名前添加extern关键字，而且不要显式地初始化变量：
在别的类中声明过了  extend "C" 使用C中的方法

但我们也可以给由extern关键字标记的变量赋一个初始值，但这样就不是一个声明了，而是一个定义：
extern int v = 2;
int v = 2;     //这两个语句效果完全一样，都是v的定义

模板的控制实例化
当两个或者多个独立编译的源文件中使用了相同的模板并且提供了相同的模板参数时，每个文件中都会有该模板的一个实例。
在大系统中，在多个文件中实例化相同的模板的额外开销可能非常严重，在C++11新标准中，我们可以通过显式实例化来避免这种开销。

----------------------------------------------------------------------------------------------------

typedef
声明新的类型，结构体中的成员，默认共有
书写方法
typedef sturct A{
    int a;int b;
}；

definde
替换 

uion 联合体
大小为最大的一个类型

struct 结构体
声明方法 使用方法 默认为public


mutex   互斥量
多线程

_valud 信号量
