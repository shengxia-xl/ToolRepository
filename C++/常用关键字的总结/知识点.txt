C/C++文字常量与常变量
https://blog.csdn.net/k346k346/article/details/46448255
----------------------------------------------------------------------------------------------------
const  代码区，不可寻址，不可更改
使用const定义的对象为常对象 以下两种定义形式在本质上是一样的
const Point point1(10,10);//常量对象
Point const point2(10,10);//常量对象

修饰指针
如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；
如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。
推荐使用int const* p，而不是使用const int* p(两者意义完全一样)

修饰函数参数(用const修饰函数参数，传递过来的参数在函数内不可以改变)
void func (const int& n)

用const修饰的类对象，该对象内的任何成员变量都不能被修改。
因此不能调用该对象的任何非const成员函数，因为对非const成员函数的调用会有修改成员变量的企图。

class A
{
 public:
    void funcA() {}
    void funcB() const {}
};

const A a;
a.funcB();    // 可以
a.funcA();    // 错误
const A* b = new A();
b->funcB();    // 可以
b->funcA();    // 错误

const修饰的声明数据成员成为常数据成员
说明： 
 1 任何函数都不能对常数据成员赋值。
 2 构造函数对常数据成员进行初始化时也只能通过初始化列表进行。
 3 常数据成员在定义时必须赋值或称为必须初始化。
 4 如果类有多个默认构造函数必须都初始化常数据成员。

const修饰的声明成员函数成为常成员函数
说明： 
 1 const是函数类型的一部分，在实现部分也要带该关键字。
 2 const关键字可以用于对重载函数的区分。
 3 常成员函数不能更新任何数据成员，也不能调用该类中没有用const修饰的成员函数，只能调用常成员函数和常数据成员。

const_cast
const_cast运算符用来修改类型的const或volatile属性。
值得注意的是：它只对指针、引用和其它的具有指向性质的类型.
一、常量指针被转化成非常量的指针，并且仍然指向原来的对象；
二、常量引用被转换成非常量的引用，并且仍然指向原来的对象。

在C++中，mutable 是为了突破 const 的限制而设置的。可以用来修饰一个类的成员变量。被 mutable 修饰的变量，将永远处于可变的状态，即使是 const 函数中也可以改变这个变量的值。

volatile修饰的数据,编译器不可对其进行执行期寄存于寄存器的优化.
这种特性,是为了多线程同步的需要

拓展：
const与define的区别

define是宏定义
1,不进行数据类型检验,注意“边缘效应” #define N (2+3)/ #define N 2+3
2,程序在预处理阶段将用define定义的内容进行替换因此程序运行时，常量表中并没有用define定义的常量，系统不为它分配内存
3,#define定义的常量在内存中有若干个拷贝。

const定义的常量
1,在编译时进行严格的类型检验
2,编译器通常不为const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。
3,const常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝

const定义的常量叫做常变量原因有二：
1，const定义常量像变量一样检查类型。
2，const可以在任何地方定义常量，编译器对它的处理过程与变量相似，只是分配内存的地方不同
----------------------------------------------------------------------------------------------------

把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。
把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。
默认初始化为0（static变量）

类中的static
类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致了它仅能访问类的静态数据和静态成员函数

不能将静态成员函数定义为虚函数。虚函数需要对象 运行时多态。

由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”

struct中的static变量,sizeof的时候不计算static变量的大小。static不属于对象

----------------------------------------------------------------------------------------
在C++中，mutable 是为了突破 const 的限制而设置的。可以用来修饰一个类的成员变量。被 mutable 修饰的变量，将永远处于可变的状态，即使是 const 函数中也可以改变这个变量的值。

volatile修饰的数据,编译器不可对其进行执行期寄存于寄存器的优化.
这种特性,是为了多线程同步的需要
----------------------------------------------------------------------------------------------------

在C++中，如果一个类有只有一个参数的构造函数，C++允许一种特殊的声明类变量的方式。在这种情况下，可以直接将一个对应于构造函数参数类型的数据直接赋值给类变量，编译器在编译时会自动进行类型转换，将对应于构造函数参数类型的数据转换为类的对象。如果在构造函数前加上explicit修饰词，则会禁止这种自动转换，在这种情况下，即使将对应于构造函数参数类型的数据直接赋值给类变量，编译器也会报错。

explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。

class People 
{ 
public: 
	int age; 
	People (int a)  {    age=a;  } 
};

void foo ( void ) 
{   
	People p1(10);  //方式一  
	People* p_p2=new People(10); //方式二  
	People p3=10; //方式三 
}
----------------------------------------------------------------------------------------------------

extern(extern一般是使用在多文件之间需要共享某些代码时)
如果想声明一个变量而非定义它，就在变量名前添加extern关键字，而且不要显式地初始化变量：
在别的类中声明过了  extend "C" 使用C中的方法

但我们也可以给由extern关键字标记的变量赋一个初始值，但这样就不是一个声明了，而是一个定义：
extern int v = 2;
int v = 2;     //这两个语句效果完全一样，都是v的定义

模板的控制实例化
当两个或者多个独立编译的源文件中使用了相同的模板并且提供了相同的模板参数时，每个文件中都会有该模板的一个实例。
在大系统中，在多个文件中实例化相同的模板的额外开销可能非常严重，在C++11新标准中，我们可以通过显式实例化来避免这种开销。

----------------------------------------------------------------------------------------------------

typedef
声明新的类型，结构体中的成员，默认public

书写方法
typedef sturct A{
    int a;int b;
}str_A；

注意点：C与C++中的情况不同
1 首先：//注意在C和C++里不同
在C中定义一个结构体类型要用typedef:
typedef struct Student
{
	int a;
}Stu;
于是在声明变量的时候就可：Stu stu1;
如果没有typedef就必须用struct Student stu1;来声明
这里的Stu实际上就是struct Student的别名。Stu==struct Student
另外这里也可以不写Student（于是也不能struct Student stu1;了，必须是Stu stu1;）
typedef struct
{
  int a;
}Stu;

但在c++里很简单，直接
struct Student
{
  int a;
};　　　　
于是就定义了结构体类型Student，声明变量时直接Student stu2；


其次：
在c++中如果用typedef的话，又会造成区别：
struct   Student   
{   
  int   a;   
}stu1;//stu1是一个变量  

 
typedef   struct   Student2   
{   
  int   a;   
}stu2;//stu2是一个结构体类型=struct Student  

 
使用时可以直接访问stu1.a
但是stu2则必须先   stu2 s2;
然后               s2.a=10;

----------------------------------------------------------------------------------------------------
#define相关用法
https://blog.csdn.net/u012611878/article/details/52534622

1.无参宏定义
#define MAXNUM 99999

2.有参宏定义
#define add(x, y) (x + y)
cout << "1 plus 1 is " << add(1, 1.5) << ".\n";
//输出“1 plus 1 is 2.5.”

该“函数”没有类型检查，有点类似模板，但没有模板安全

3.宏定义中的特殊操作符

（1）# 
#define PSQR(x) printf("the square of" #x "is %d.\n",(x)*(x))
y = 4;
PSQR(y); //输出：the square of y is 16.
PSQR(2+4); //输出：the square of 2+4 is 36.

（2）##
#define XNAME(n) x##n
#define PXN(n) printf("x"#n" = %d\n",x##n)
int XNAME(1)=12;//int x1=12;
PXN(1);//printf("x1 = %d\n", x1); //输出：x1=12

##n  替换为参数列表中的n    XNAME(1)   =>  x ##n = x 1
#n   打印时，使用#n来调用替换后的 x##n 

（3）可变参数宏 …和__VA_ARGS__
__VA_ARGS__ 是一个可变参数的宏
    #define PR(...) printf(__VA_ARGS__)
  PR("weight = %d, shipping = %d",wt,sp);

 ## __VA_ARGS__
如果可变参数被忽略或为空，’##’操作将使预处理器(preprocessor)去除掉它前面的那个逗号

__FILE__ 宏在预编译时会替换成当前的源文件名 
__LINE__宏在预编译时会替换成当前的行号  __FUNCTION__宏在预编译时会替换成当前的函数名称

4.宏定义中的多行定义
在句尾的时候，增加'/'

5.宏定义中的条件编译
#ifdef WINDOWS 
...... 
(#else)
......
 #endif
可以在编译的时候通过#define设置编译环境。

6.如何取消宏
//定义宏 #define [MacroName] [MacroValue] 
//取消宏 #undef [MacroName]

7.防止重复包含头文件 
#ifndef __headerfileXXX__ 
#define __headerfileXXX__ 
… 
文件内容
… 
#endif

----------------------------------------------------------------------------------------------------

union 联合体
1)联合体是一个结构；
2)它的所有成员相对于基地址的偏移量都为0；
3)此结构空间要大到足够容纳最"宽"的成员；
4)其对齐方式要适合其中所有的成员

1)大小足够容纳最宽的成员；
2)大小能被其包含的所有基本数据类型的大小所整除。

union U1  
{  
    int n;  
    char s[11];  
    double d;  
}; 
sizeof(U1) = 16  11 + 5 = 8 * 2

----------------------------------------------------------------------------------------------------