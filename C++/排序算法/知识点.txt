常用算法总结
http://www.cnblogs.com/eniac12/p/5329396.html
十大经典排序算法（动图演示）
https://www.cnblogs.com/onepixel/articles/7674659.html
----------------------------------------------------------------------------------------------------
比较排序：

冒泡排序 稳定 n^2
选择排序 不稳定 n^2
插入排序 稳定   n^2
希尔排序 不稳定 nlogn ~ n^2
快速排序 不稳定 nlogn
归并排序 稳定   nlogn
堆排序   不稳定 nlogn


非比较排序：
计数排序 稳定 n+k
桶排序   稳定 n+k
基数排序 稳定 n+k

----------------------------------------------------------------------------------------------------

冒泡排序
每一次都比较，然后交换。
每一趟排序最大的数都排在最后。
进阶：鸡尾酒排序
此算法与冒泡排序的不同处在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。


选择排序
从排序的队列中选择一个最大的，放在末尾。
每一趟排序只做一次交换


插入排序 (左手手牌，右手抓牌)
右手的牌与左手的牌依次比较，反复把已排序元素逐步向后挪位，为最新元素提供插入空间
插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。
进阶：二分插入排序
对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数


希尔排序
希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本
希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。


归并排序
归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。


堆排序


快速排序
从序列中挑出一个元素，作为"基准"(pivot).
把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。
N次排序之后，至少有N个数字在最终排序上 


----------------------------------------------------------------------------------------------------

Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？
答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。 
