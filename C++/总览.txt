提交声明：
[xuli]: 更新
1、[提交文件名] 文件类型
	变更点1
2、[提交文件名] 文件类型 
	变更点1
	变更点2
------------------------
已经完成的总结：


String:
[知识点]
1、C字符串与C++字符串的区别
2、关于string char* /char[] 的相互转换
3、sizeof与strlen 使用中的区别
[代码]
1、几种常用的C字符串常用函数的实现(strlen strcat strcpy strcmp)
2、字符串拷贝中，考虑内存重叠的情况


VariableInit：
[知识点]
1、内置变量的初始化
2、类类型变量的自动初始化
[代码]
1、基本类型的初始化
2、类类型中，const、static、引用、指针等类型的成员变量的初始化方式


Binary：
[知识点]
1、补码反码原码的原理
2、为何会有反码和补码
3、补码中的溢出
4、代码中的位运算符
5、位移运算中的溢出
[代码]
1、bitset的使用
2、二进制八进制十六进制


基本数据类型：
[知识点]
1、(32进制与64进制中的)基本数据类型的大小(没有，需要补充)
2、struct大小的计算与方法的总结(需要补充涉及继承时，类的大小)
3、基本数据类型的打印格式
[代码]
1、struct大小的计算
2、基本数据类型的打印


继承：
[知识点]
1、继承分类
2、继承的二义性
3、继承和成员函数的初始化顺序
4、重载/重写/覆盖(隐藏)
5、虚函数表(需要补充)
[代码]
1、const区分重载
2、继承和成员函数的初始化顺序
3、基本继承 实现多态


模板：
[知识点]
1、模板的基本写法 函数/类 模板
2、模板中的继承
[代码]
1、模板的书写


常用的关键字：
[知识点]
1、const
2、static
3、volatile mutable
4、exlipct
5、extern
6、typedef define(需要补足)
7、多线程相关的关键字
[代码]
等待补充


容器：
[知识点]
1、STL容器中的线程安全
2、STL中常用的容器  vector list deque map set
[代码]
等待补充：
map的实现 红黑树相关 


排序算法：
[知识点]
1.常用算法的介绍
冒泡 选择 插入 希尔排序 快速排序 归并排序
计数排序 基数排序 桶排序
[代码]
等待补充


多线程：
[知识点]
等待归纳
基本知识点 进程 线程的区别 通信等
[代码]
等待完善


网络：
[知识点]
等待归纳
基本知识点  UDP TCP的特点  发生阻塞、丢包如何处理
[代码]
等待补充
TCP/IP 代码书写


数据结构：
[知识点]
等待归纳
树 堆 的特点
[代码]
等待完善


内存泄漏：
[知识点]
等待补充
检查工具vld C++中的内存处理 如何避免
[代码]
暂无


知识维度
[知识点]
linux内核
lua脚本
python脚本
C11特性  lamda表达式  智能指针  auto类型等
CTR   window运行库
RTTI (类似java中的反射机制)
RAII (资源控制 声明周期相关)


----------------------------------------------------------------------------------------------------
文件操作

指针与数组
指针与引用

拷贝：
拷贝构造函数
重载等号运算符等
深拷贝浅拷贝等

----------------------------------------------------------------------------------------------------
知识维度
想到就添加

------------------------
C++11的特性
auto关键字 自动类型推导
decltype decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型)
nullptr 解决原来C++中NULL的二义性问题而引进的一种新的类型
lambda
可变参数的模板

------------------------

http://lib.csdn.net/article/cplusplus/21896
RAII（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术。 
　　RAII 的一般做法是这样的：在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做法有两大好处： 
不需要显式地释放资源。 
采用这种方式，对象所需的资源在其生命期内始终保持有效。

------------------------
RTTI概念
RTTI(Run Time Type Identification)即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。

RTTI机制的产生
为什么会出现RTTI这一机制，这和C++语言本身有关系。和很多其他语言一样，C++是一种静态类型语言。其数据类型是在编译期就确定的，不能在运行时更改。然而由于面向对象程序设计中多态性的要求，C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。和Java相比，C++要想获得运行时类型信息，只能通过RTTI机制，并且C++最终生成的代码是直接与机器相关的。

Java中任何一个类都可以通过反射机制来获取类的基本信息（接口、父类、方法、属性、Annotation等），而且Java中还提供了一个关键字，可以在运行时判断一个类是不是另一个类的子类或者是该类的对象，Java可以生成字节码文件，再由JVM（Java虚拟机）加载运行，字节码文件中可以含有类的信息。