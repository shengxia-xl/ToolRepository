提交声明：
[xuli]: 更新
1、[提交文件名] 
	变更点1
2、[提交文件名] 
	变更点1
------------------------
已经完成的总结：

String:
1、C字符串与C++字符串的区别
2、string char* 类型间的区别于联系
3、几种常用的C字符串常用函数的实现(strlen strcat strcpy strcmp)
4、sizeof与strlen 使用中的区别

VariableInit：
1、关于变量的初始化
2、基本类型变量
3、类类型变量
4、类类型中的基本变量

Binary：
1、补码反码原码的原理
2、二进制中的位运算
3、探讨位移运算中的溢出

基本数据类型：
1、(32进制与64进制中的)基本数据类型的大小
2、struct大小的计算与方法的总结

1、继承
初始化顺序
重载/重写/覆盖(隐藏)
虚函数 纯虚函数 虚函数表

C++11的特性
auto关键字 自动类型推导
decltype decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型)
nullptr 解决原来C++中NULL的二义性问题而引进的一种新的类型
lambda
可变参数的模板

http://lib.csdn.net/article/cplusplus/21896
RAII（Resource Acquisition Is Initialization）是一种利用对象生命周期来控制程序资源（如内存、文件句柄、网络连接、互斥量等等）的简单技术。 
　　RAII 的一般做法是这样的：在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。借此，我们实际上把管理一份资源的责任托管给了一个对象。这种做法有两大好处： 
不需要显式地释放资源。 
采用这种方式，对象所需的资源在其生命期内始终保持有效。


RTTI概念
RTTI(Run Time Type Identification)即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。

RTTI机制的产生
为什么会出现RTTI这一机制，这和C++语言本身有关系。和很多其他语言一样，C++是一种静态类型语言。其数据类型是在编译期就确定的，不能在运行时更改。然而由于面向对象程序设计中多态性的要求，C++中的指针或引用(Reference)本身的类型，可能与它实际代表(指向或引用)的类型并不一致。有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。和Java相比，C++要想获得运行时类型信息，只能通过RTTI机制，并且C++最终生成的代码是直接与机器相关的。

Java中任何一个类都可以通过反射机制来获取类的基本信息（接口、父类、方法、属性、Annotation等），而且Java中还提供了一个关键字，可以在运行时判断一个类是不是另一个类的子类或者是该类的对象，Java可以生成字节码文件，再由JVM（Java虚拟机）加载运行，字节码文件中可以含有类的信息。

模板
模板的使用
继承

常用的关键字
const
static

------------------------
最近重点：
 


多线程 多线程时的操作
网络编程 tcp ip 

数据结构
map的实现  哈希表 红黑树
排序算法 

------------------------
static 关键字
class A {
private:
	static int a;
	int b;
public:
	static int getANum();
	int getBNum();
}

// static int A::a = 1; // error 不能带static关键字
int A::a = 1;

// static int A::getNum(){return a;} // error 不能带static关键字
int A::getANum() {return a;}
// int A::getANum() {return b;} // error static成员函数无法访问非static关键字

int A::getBNum() {return a;}// 非静态成员函数可以访问静态成员



static不管在何处声明，都在全局区。都有默认初始化0
--------

还需要完成的：

文件操作 文件操作

指针的深度了解

拷贝：
拷贝构造函数
重载等号运算符等
深拷贝浅拷贝等


。。。

容器


文件操作

网络编程

多线程编程

排序算法

搜索算法