16位编译器

char ：1个字节
char*(即指针变量): 2个字节
short int : 2个字节
int：  2个字节
unsigned int : 2个字节
float:  4个字节
double:   8个字节
long:   4个字节
long long:  8个字节
unsigned long:  4个字节


32位编译器

char ：1个字节
char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
short int : 2个字节
int：  4个字节
unsigned int : 4个字节
float:  4个字节
double:   8个字节
long:   4个字节
long long:  8个字节
unsigned long:  4个字节


64位编译器

char ：1个字节
char*(即指针变量): 8个字节
short int : 2个字节
int：  4个字节
unsigned int : 4个字节
float:  4个字节
double:   8个字节
long:   8个字节
long long:  8个字节
unsigned long:  8个字节

----------------

关于结构体计算的注意点：
1、static类型的变量，不计算在struct 对象的大小中
2、函数，不计算在struct 对象的大小中
3、空结构体大小为1(使空类或空结构体在实例化后在内存得到了独一无二的地址)

-------
结构体对齐的原因：(浪费空间用来节省时间”，这就是结构对齐的主要原因)

结构体大小的计算方式：
1. 首先判断是否需要内存对齐(看环境)
2. 累加时，已经计算的结构体大小是当前的大小的倍数 
3. 结构体总大小为结构体内最大类型的整数倍

 1 2 4 = 8   1 + 1(补2) + 2 + 4 
 1 4 2 = 12  1 + 3(补2) + 4 + 2 + 2(补3)
 2 1 4 = 8   2 + 1 + 1(补2) + 4
 2 4 1 = 12  2 + 2(补2) + 4 + 1 + 3(补3)
 4 1 2 = 8   4 + 1 + 2 + 1(补3)
 4 2 1 = 8   4 + 2 + 1 + 1(补3)

注意点：
联合体大小就是成员中最大类型的大小
数组的话，计算方式为N个基本类型(相关3性质 char[10], 最大类型为char 而不是[10])
成员包含结构体的结构体(拆开来计算)